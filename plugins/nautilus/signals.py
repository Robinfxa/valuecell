"""Trading Signal Models.

This module defines the signal-based architecture where Nautilus strategies
generate trading signals instead of directly executing orders. Signals are
then processed by the execution bridge which forwards them to ValueCell.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, Optional
import time


class SignalAction(Enum):
    """Trading signal action types."""
    BUY = "BUY"
    SELL = "SELL"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"
    CLOSE_ALL = "CLOSE_ALL"


class SignalType(Enum):
    """Signal type classification."""
    ENTRY = "ENTRY"          # New position entry
    EXIT = "EXIT"            # Close existing position
    ADJUST = "ADJUST"        # Modify existing position
    STOP_LOSS = "STOP_LOSS"  # Stop loss trigger
    TAKE_PROFIT = "TAKE_PROFIT"  # Take profit trigger


@dataclass
class TradingSignal:
    """
    Trading signal generated by a strategy.
    
    Signals are the output of Nautilus strategies and the input to
    the execution bridge. They contain all information needed to
    create an order via ValueCell.
    """
    
    # Core fields
    action: SignalAction
    """What action to take (BUY/SELL/CLOSE)"""
    
    symbol: str
    """Trading pair symbol (e.g., 'BTC/USDT')"""
    
    quantity: float
    """Order quantity"""
    
    # Identity
    strategy_id: str
    """ID of the strategy that generated this signal"""
    
    signal_id: str = field(default_factory=lambda: f"sig_{int(time.time() * 1000)}")
    """Unique signal identifier"""
    
    # Timing
    timestamp: float = field(default_factory=time.time)
    """Signal generation timestamp"""
    
    # Classification
    signal_type: SignalType = SignalType.ENTRY
    """Type of signal (entry/exit/etc)"""
    
    # Order details
    order_type: str = "MARKET"
    """Order type: MARKET | LIMIT | STOP"""
    
    price: Optional[float] = None
    """Limit/stop price (if applicable)"""
    
    # Metadata
    reason: str = ""
    """Human-readable reason for this signal"""
    
    confidence: float = 1.0
    """Signal confidence (0.0 - 1.0)"""
    
    metadata: Dict[str, Any] = field(default_factory=dict)
    """Additional metadata"""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "signal_id": self.signal_id,
            "strategy_id": self.strategy_id,
            "action": self.action.value,
            "symbol": self.symbol,
            "quantity": self.quantity,
            "signal_type": self.signal_type.value,
            "order_type": self.order_type,
            "price": self.price,
            "timestamp": self.timestamp,
            "reason": self.reason,
            "confidence": self.confidence,
            "metadata": self.metadata
        }
    
    @classmethod
    def create_buy_signal(
        cls,
        symbol: str,
        quantity: float,
        strategy_id: str,
        **kwargs
    ) -> "TradingSignal":
        """Create a BUY signal."""
        return cls(
            action=SignalAction.BUY,
            symbol=symbol,
            quantity=quantity,
            strategy_id=strategy_id,
            signal_type=SignalType.ENTRY,
            **kwargs
        )
    
    @classmethod
    def create_sell_signal(
        cls,
        symbol: str,
        quantity: float,
        strategy_id: str,
        **kwargs
    ) -> "TradingSignal":
        """Create a SELL signal."""
        return cls(
            action=SignalAction.SELL,
            symbol=symbol,
            quantity=quantity,
            strategy_id=strategy_id,
            signal_type=SignalType.ENTRY,
            **kwargs
        )
    
    @classmethod
    def create_close_signal(
        cls,
        symbol: str,
        strategy_id: str,
        **kwargs
    ) -> "TradingSignal":
        """Create a CLOSE position signal."""
        return cls(
            action=SignalAction.CLOSE_ALL,
            symbol=symbol,
            quantity=0.0,  # Will be determined by actual position
            strategy_id=strategy_id,
            signal_type=SignalType.EXIT,
            **kwargs
        )


@dataclass
class SignalResult:
    """
    Result of processing a trading signal.
    
    This is returned by the execution bridge after attempting
    to execute a signal via ValueCell.
    """
    
    signal_id: str
    """ID of the signal that was processed"""
    
    success: bool
    """Whether execution was successful"""
    
    order_id: Optional[str] = None
    """ValueCell order ID (if successful)"""
    
    error_message: Optional[str] = None
    """Error message (if failed)"""
    
    execution_time: float = field(default_factory=time.time)
    """When the signal was executed"""
    
    metadata: Dict[str, Any] = field(default_factory=dict)
    """Additional execution details"""
